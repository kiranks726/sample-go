name: Continuous Integration

on:
  push:
    branches:
      - "**"
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [master, release/*, develop, feature/*]

  # workflow_call enables this workflow to be called in another workflow
  workflow_call:

jobs:
  build:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      checks: write

    env:
      NODE_VERSION: 16.14.0
      GO_VERSION: 1.17

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Nodejs ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install dependencies
        run: make install

      # - name: Run lint and create annotations in jobs summary
      #   uses: golangci/golangci-lint-action@v3
      #   # TODO: Remove below parameter
      #   continue-on-error: true
      #   with:
      #     version: "latest"
      #     working-directory: ${{ github.workspace }}/backend/mainmodule

      - name: Configure aws
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: arn:aws:iam::593186514662:role/github-actions-role
          role-session-name: GithubCIActions
          aws-region: us-east-1

      # This generates Cloud formation template which is referenced by the sst unit test cases.
      # The generated Cloud formation template is only used for running tests against and not deployed.
      - name: Synthesize stack
        run: npx sst build --stage dev

      # - name: Run test
      #   run: make test

      - name: Display coverage metrics in Pull Request and jobs summary
        if: github.event_name == 'pull_request'
        uses: 5monkeys/cobertura-action@master
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          path: ${{ github.workspace }}/reports/coverage/coverage_report.xml
          minimum_coverage: 70
          fail_below_threshold: false
          show_line: true
          show_branch: true
          show_missing: true
          only_changed_files: false
          report_name: Coverage Metrics

      - name: Run diff to display infrastructure changes in Pull Request
        if: github.event_name == 'pull_request'
        env:
          PR_COMMENTS_URL: ${{ github.event.pull_request.comments_url }}
          PR_URL: ${{ github.event.pull_request.html_url}}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          npx sst telemetry disable
          npx sst diff --stage dev 2>&1 | tee infra_changes_report.log
          output=$(cat infra_changes_report.log)
          if [[ $output == *"no differences"* ]]; then
            echo "Skipping commenting on the Pull Request since there is no infrastructure changes"
          else
            gitShortSha=$(git rev-parse --short ${COMMIT_SHA})
            prCommitUrl="${PR_URL}/commits/${COMMIT_SHA}"

            commentWrapper="#### Differences between the infrastructure specified in the current state of the app and the currently deployed application
            #### Generated against <a href="${prCommitUrl}">${gitShortSha}</a>
            <details><summary>Show Output</summary>

            \`\`\`
            ${output}
            \`\`\`

            </details>
            "
            payload=$(echo "${commentWrapper}" | jq -R --slurp '{body: .}')
            echo "${payload}" | curl -s -S --header "authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" --header "Content-Type: application/json" --data @- "${PR_COMMENTS_URL}" > /dev/null
          fi

      - name: Add action summary
        if: github.event_name == 'pull_request'
        env:
          REPO: ${{ github.event.pull_request.head.repo.name }}
          REPO_URL: ${{ github.event.pull_request.head.repo.html_url }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha }}
          PR_URL: ${{ github.event.pull_request.html_url}}
        run: |
          prCommitUrl=${PR_URL}/commits/${COMMIT_SHA}
          shortSha=$(git rev-parse --short ${COMMIT_SHA})
          echo "## Sources" >> $GITHUB_STEP_SUMMARY
          echo "|Repository|Commit sha|" >> $GITHUB_STEP_SUMMARY 
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY 
          echo "|<a href='${REPO_URL}'>${REPO}</a>|"\
                "<a href='${prCommitUrl}'>${shortSha}</a>|" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**_NOTE:_** Coverage Metrics, Infrastructure changes(if any) can be found"\
                "as a comment with commit sha on the Pull request. Lints(if any) can also be"\
                "found as annotations in the Files changed tab on the Pull request" >> $GITHUB_STEP_SUMMARY
    
      - name: Upload build to artifact
        uses: actions/upload-artifact@v3
        with:
          name: sample-go
          path: |
            ${{ github.workspace }}/.build/
            ${{ github.workspace }}/.sst/
        # ${{ github.workspace }}/sst.json
      
  # validate-version:
  #   runs-on: ubuntu-latest

  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v3
  #       with:
  #         fetch-depth: 0

  #     - name: Check if version is in semantic format
  #       run: |
  #         import json
  #         import os
  #         import sys
  #         with open("package.json", "r") as f:
  #           data = json.load(f)
  #           version = data["version"]
  #           if len(version.split('.')) != 3 :
  #             sys.exit("Version is not in semantic format")
            
  #         env_file = os.getenv("GITHUB_ENV")
  #         with open(env_file, "a") as f:
  #           f.write(f"VERSION={version}")

  #       shell: python

  #     - name: Check if version is in CHANGELOG.md
  #       run: |
  #         import os
  #         import sys
  #         version = os.getenv("VERSION")
            
  #         with open("CHANGELOG.md", "r") as f:
  #           text = f.read()
  #         if version not in text:
  #           sys.exit("Version is not in CHANGELOG.md")
  #       shell: python

  #     - name: Check if git tag already exists
  #       run: |
  #         tag=$(git tag -l "$VERSION")
  #         echo "Tag found is $tag"
  #         if [ ! -z "$tag" ]; then
  #           echo "ERROR: git tag already exists"
  #           exit 1
  #         fi
